\documentclass[a4paper]{book}

\include{pyscript_defs}

% this code hacked from that of R Chandrasekhar from UWA
\newif\ifpdf
\ifx\pdfoutput\undefined
        \pdffalse    % we are not running pdfLaTeX
\else
        \pdfoutput=1 % we are running pdfLaTeX
        \pdftrue
\fi

\ifpdf
        \DeclareGraphicsExtensions{.pdf}  % this command defined in graphicx
        \pdfcompresslevel=9  % 0: no compression, 9: highest compression
                             % or, set compress_level 9 in file pdftex.cfg
\else
        \DeclareGraphicsExtensions{.eps}
\fi

\begin{document}

\begin{titlepage}
\begin{center}
\vspace*{3cm}
\LARGE

\includegraphics{logo}\\[4cm]

{\Huge \emph{Pyscript}}\\[1cm]
\emph{Postscript drawing in Python}\\[2cm]

v 0.2\\[2cm]

Alexei Gilchrist\\
Paul Cochrane
\end{center}
\end{titlepage}

\frontmatter

\tableofcontents

\mainmatter

%==========================================================================
\chapter{Introduction}
\label{cha:introduction}


\section{Overview}

\Verb|Pyscript| is a python package for creating high-quality postscript
drawings.  It began from the frustration of trying to create some good figures
for publication that contained some abritrary \LaTeX{} expressions, and has
been largely inspired by \Verb|mpost|. What began as some quick-n-dirty hacks
has evolved into a really useful tool (after several rewrites). Essentially a
figure is scripted using python and some pre-defined objects such as
rectangles, lines, text etc. This approach allows for a precise placement of
all the components of a figure.

Some of the key features are
\begin{itemize}
\item All scripting is done in python, which is a high-level, easy to
  learn, well developed scripting language.
\item All the objects can be translated, scaled, rotated, \ldots in fact any
affine transformation.  
\item The plain text object is automatically kerned.
\item You can place abritrary \LaTeX{} expressions on your figures.
\item You can create your own objects, and develop a library of figure 
primitives. 
\item Output is publication quality.
\end{itemize}

\section{Conventions and Pitfalls}
\label{sec:conventions}

Just to be clear from the outset, some conventions follow, and some common
pitfalls to be aware of \ldots

\begin{itemize}
\item The co-ordinate system is as you learned at school in maths \ldots
  the $x$-axis extends to the right, the $y$-axis extends upwards. I know, 
  this is obvious, but a suprising number of graphics libraries invert the 
  $y$-axis.
\item Angles are in degrees and proceed clockwise from the top \ldots
  just like your clock.  Often, key points are labeled by the compass
  points: n, ne, e, se, s, sw, w, nw.
\item The default units are postscript points,
  $1\mathrm{cm}=28.346\mathrm{pp}$. For a figure, the default can
  easily be changed with the command
  \Verb|defaults.units=UNITS['cm']|. All of the examples in this manual are
  in \texttt{cm}.
\item In python, an integer divided by an integer is truncated to an
  integer, To avoid this use floating point numbers, e.g. \Verb|2/3 = 0|
  but \Verb|2/3. = 0.6666|.
\item Backslashes in strings have special significance, such as
  denoting newlines (\Verb|"\n"|). This can be frustrating for
  entering \LaTeX{} expresions. You can turn off this interpretation by
  using raw strings: just prepend an ``r'' to the string e.g.
  \Verb|g=r"$\alpha$"|
\end{itemize}


\section{Tutorial}
\label{sec:tutotial}

As a tutorial, we'll take a detailed look at the script that created the
following figure:
\begin{center}
  \includegraphics{tutorial}
\end{center}
In the following script, we've interdispersed 
comments explaining what we're doing, the full script is available
with the other examples and is called \texttt{tutorial.py}.

First import the \Verb|pyscript| libraries, and we'll grab some objects
from \Verb|pyscript.lib.quantumcircuits| too. Most scripts would have
something like this at the beginning.
\begin{python}
from pyscript import *
from pyscript.lib.quantumcircuits import *
\end{python}
The default units are in postscript points. I prefer to use
\texttt{cm} so switch the units here. The default units are stored in
\Verb|defaults.units| which is just a number giving giving the
multiplying factor compared to postscript points. \Verb|UNITS| is a
dictionary of factors for some common units.
\begin{python}
defaults.units=UNITS['cm']
\end{python}
There's a bunch of \LaTeX{} macros I use often. Rather than defining
them each time they're needed, well define them in the \Verb|tex_head|
variable in \Verb|defaults|, which defines the start of the
environment where \emph{all} the \LaTeX{} is processed.
\begin{python}
defaults.tex_head=r"""
\documentclass{article}
\pagestyle{empty}
\usepackage{amsmath}

\newcommand{\ket}[1]{\mbox{$|#1\rangle$}}
\newcommand{\bra}[1]{\mbox{$\langle #1|$}}
\newcommand{\braket}[2]{\mbox{$\langle #1|#2\rangle$}}
\newcommand{\ketbra}[2]{\mbox{|#1$\rangle\langle #2|$}}
\newcommand{\op}[1]{\mbox{\boldmath $\hat{#1}$}}
\newcommand{\R}[3]{%
\renewcommand{\arraystretch}{.5}
$\begin{array}{@{}c@{}}{#1}\\{#2}\end{array}{#3}$
\renewcommand{\arraystretch}{1}
}
\begin{document}
"""
\end{python}
Now, define the colors of some objects here to make it easy to change
them everywhere in the figure later if we need to. There are a whole
variety of ways to specify a color, we'll use RGB values here.
\begin{python}
blue=Color(.65,.65,1)
green=Color(.65,1,.65)
\end{python}
There's a component of the figure we'll use several times, so for
convenience, define it here as a function which returns the object. 
A separate class would also be possible, but would involve more work.
We could also have created the object and used the \Verb|copy()| method
to make duplicates, but that would be clumsy.
\begin{python}
def BellDet(c=P(0,0)):

    H=P(0,.8)
    W=P(.5,0)
\end{python}
\Verb|D| is a D-shaped path filled in with the blue color we defined earlier.
\begin{python}
    D=Path(c+H,
           C(c+H+W),
           c+W,
           C(c-H+W),
           c-H,bg=blue,
           )
\end{python}
Now return everything as a \Verb|Group|, which will then get treated as a unit 
in the rest of the figure.
\begin{python}
    return Group(
        Path(c-H,c+H,linewidth=2),
        D,
        TeX(r'$\mathcal{B}$',c=D.c)
        )
\end{python}
To create the big gray box, we've tweaked the parameters after
examining the results so that it looks nice. The dash specification is
straight from postscript.
\begin{python}
offline=Rectangle(height=4,width=5.5,e=P(3.5,1.5),
                  dash='[3 ] 0',bg=Color(.85))
\end{python}
Now render the figure! What about all the other bits of the figure?
Well, we'll render them on the fly since we don't need to refer to the
objects again. \Verb|render| is a function that can take a variable
number of arguments, we'll create some of the objects in the
actual function call.

Objects are rendered in the order that they appear in the \Verb|render()| 
call.  So, we'll put on the big gray box first, this way it'll appear to be 
behind everything else.
\begin{python}
render(
    offline,
    TeX('offline',nw=offline.nw+P(.1,-.1)),
\end{python}
Now draw the lines, and some dots. A rough sketch on a piece of paper
beforehand will really help in figuring out what the co-ordinates are
for what you want to draw. You can always tweak them later.
\begin{python}
    Path(P(5,0),P(-.3,0),P(-.6,.5),P(-.3,1),P(2,1)),
    Path(P(2,2),P(-.3,2),P(-.6,2.5),P(-.3,3),P(3.7,3)),
    Path(P(-1,4),P(3.7,4)),

    Dot(P(-.6,.5)),
    Dot(P(-.6,2.5)),
\end{python}
Now add a double line, notice how the central region of the line in
the figure is unbroken? Can you guess how it was done?
\begin{python}
    classicalpath(Path(P(2.1,1.5),P(4.5,1.5),P(4.5,0)),
                  Path(P(3,1.5),P(3,0)),
                  Path(P(3.8,3.5),P(4.5,3.5),P(4.5,1.5)),
                  ),
\end{python}
Use the function we defined earlier to add those large detectors to the figure.
\begin{python}
    BellDet(P(2,1.5)),
    BellDet(P(3.7,3.5)),
\end{python}
Add some boxed equations to the figure. This object is from the
\Verb|quantumcircuits| library, and will add a box around an
abritrary object.
\begin{python}
    Boxed(TeX(r'$D\left(\frac{i\theta}{2\alpha^2}\right)$'),c=P(1,2),bg=green),

    Boxed(TeX('$X$'),c=P(3,0),bg=green),
    Boxed(TeX('$Z$'),c=P(4.5,0),bg=green),
\end{python}
Finally, add some \LaTeX{} expressions (notice some of the macros we
defined earlier), and give the filename to write the postscript to.
N.B.  keywords, such as \Verb|file=|, have to go after parameters in a
function call.
\begin{python}
    TeX(r'$\ket{B_{00}}$',e=P(-.7,.5)),
    TeX(r'$\ket{B_{00}}$',e=P(-.7,2.5)),
    TeX(r'$\ket{Q}$',e=P(-1.1,4)),

    file="tutorial.eps",
    )
\end{python}

We're done. Sit back and admire the figure.
%==========================================================================
\chapter{Pyscript Objects}
\label{cha:base-objects}

These are the basic \Verb|pyscript| objects and functions. At the
begining of each class there is a brief description of the structure
of the class showing the relevant methods and members. See also
figure~\ref{fig:classes} on page~\pageref{fig:classes} for an
indication of how the classes fit together.

\section{Base Objects}

These are classes which add layers of functionality to pyscript objects.
Normally you wouldn't use these classes directly unless you're creating new 
pyscript objects. We'll decribe them here because they summarise what
you can do with pyscript objects.

%--------------------------------------------------------------------------
\subsection{PsObj()}
\label{sec:psobj}
\begin{python}
class PsObj(object):
    def __call__(self,**dict):
        Set a whole lot of attributes in one go

    def copy(self,**dict):
        return a copy of this object
        with listed attributes modified

    def __str__(self):
        return actual postscript string to generate object

    def body(self):
        subclasses should overide this for generating postscipt code

    def bbox(self):
        return objects bounding box
\end{python}

Base class of which most (all?) \Verb|pyscript| classes are subclass.

A list of parameters can be set when an object is created with
calls like \Verb|t=Text('Hello',font='Helvetica')|
or by calling the object like a function as in \Verb|t(sw=P(0,2))|.
The parameters are also available singly as attributes: \Verb|t.sw| etc.

Printing an object produces the actual postscript code.

Objects may be copied with the \Verb|copy()| function and new
parameters can be passed in as arguments eg \Verb|s = t.copy(sw=P(0,0))|.

%--------------------------------------------------------------------------
\subsection{AffineObj()}
\label{sec:affineobj}
\begin{python}
class AffineObj(PsObj):

    o=P(0,0)
    T=Matrix(1,0,0,1)

    def concat(self,t,p=None):
        concat matrix t to tranformation matrix
          t: a 2x2 Matrix dectribing Affine transformation
          p: the origin for the transformation
          return: reference to self

    def move(self,*args):
        translate object by a certain amount
          param args: amount to move by, can be given as
            - dx,dy
            - P
          return: reference to self

    def rotate(self,angle,p=None):
        rotate object, 
        the rotation is around p when supplied otherwise
        it's the objects origin
          angle: angle in degrees, clockwise
          p: point to rotate around (external co-ords)
          return: reference to self

    def scale(self,sx,sy,p=None):
        scale object size (towards objects origin or p)
          sx sy: scale factors for each axis
          p: point around which to scale
          return: reference to self

    def itoe(self,p_i):
        convert internal to external co-ords
          p_i: intrnal co-ordinate
          return: external co-ordinate
        
    def etoi(self,p_e):
        convert external to internal co-ords
          p_e: external co-ordinate
          return: internal co-ordinate
\end{python}

A base class for objects that should implement affine transformations
(such as scaling, rotating etc), this should apply to any object that
draws on the page.


%--------------------------------------------------------------------------
\subsection{Area()}
\label{sec:area}
\begin{python}
class Area(AffineObj):

    o=P(0,0)
    width=0
    height=0

    n, ne, e, se, s, sw, w, nw, c  ... see description below
\end{python}

A Rectangular area defined by the south-west corner and the width and height.
This object mainly adds the ability to align to named compass points on the 
circumference see figure below.

\begin{center}
  \includegraphics[width=.25\textwidth]{fig_area}
\end{center}

These points are always returned in external co-ordinates.

%--------------------------------------------------------------------------
\section{Drawing Objects}

%--------------------------------------------------------------------------
\subsection{Common Attributes}
\label{sec:draw-attr}

Most of the objects that actually draw something on the page
share a common set of attributes to set things like the line thickness
etc. 

\begin{itemize}
\item \textbf{fg}: A \Verb|Color()|, the colour for the ink in the
  foreground.  Some objects allow switching this off with the value
  \Verb|None| in which case only the fill (if it's used) will be
  drawn.
\item \textbf{bg}: A \Verb|Color()|, the fill color if the object
  supports this. A value of \Verb|None| means no fill (transparent).
\item \textbf{linewidth}: The linewidth in pp.
\item \textbf{linecap}: How to finish the ends of lines. 0=butt,
  1=round, 2=square.
\item \textbf{linejoin}: How to treat corners. 0=miter, 1=round,
  2=bevel.
\item \textbf{miterlimit}: Where to cut off the mitres (if you're
  using mitres in linejoins). 1.414 cuts off miters at angles less
  than 90 degrees, 2.0 cuts off miters at angles less than 60 degrees,
  10.0 cuts off miters at angles less than 11 degrees, 1.0 cuts off
  miters at all angles, so that bevels are always produced.
\item \textbf{dash:} The dash pattern to use for the forground lines.
  Currently this follows the postscript syntax. e.g. \Verb|"[]"| is a
  solid line, \Verb|"[2 3] 0 "| is a dashed line with ink for 2 pp gap
  for 3 pp and an initial offset for the ink of 0 pp. At some time in
  the future there may be a convenience class to set this.
\end{itemize}



%--------------------------------------------------------------------------
\subsection{Rectangle()}
\label{sec:rectangle}
%\begin{python}
%\end{python}

\begin{center}
  \includegraphics[width=.25\textwidth]{fig_rectangle}
\end{center}

%--------------------------------------------------------------------------
\subsection{Circle()}
\label{sec:circle}
\begin{python}
    bg=None
    fg=Color(0)
    r=1.0
    start=0
    end=360
    linewidth=defaults.linewidth
    dash=defaults.dash
    
    n, ne, e, se, s, sw, w, nw, c  ... see description below

    def locus(self,angle,target=None):
        Set or get a point on the locus

        @param angle: locus point in degrees
                      (Degrees clockwise from north)
        @param target: target point
        @return: target is None: point on circumference at that angle
                 else: set point to the target, and return reference
                       to object

\end{python}
Draw a circle. The circle is specified by its position and its
radius.  You can also specify part of a circle with the attributes
\Verb|start| and \Verb|end| which are in degrees clockwise from the
top. As with the \Verb|Rectangle| there are named points on the
enclosing square that corresponds to the compass points which can be
read or set.
\begin{center}
  \includegraphics[width=.25\textwidth]{fig_circle}
\end{center}
In addition an abtritrary point on the circumference can be read or
set by using the \Verb|locus()| method --- with one parameter (the
angle on the locus) the locus point is returned; with an additional
target point supplied, the locus point is set to the target point.
\begin{example}
\begin{python}
c=Circle(r=.5,bg=Color('dandelion'))
g=Group()
for ii in range(0,360,30):
    g.append(
        Circle(r=.2,bg=Color('white')).locus(180+ii,c.locus(ii))
        )
render(c,g,file=...)
\end{python}
\begin{center}
  \includegraphics{fig_circle_eg1}
\end{center}
\end{example}
\begin{example}
\begin{python}
g=Group(Rectangle(sw=P(0,0),width=2,height=2),
        Circle(r=1,sw=P(0,0)),
        Circle(r=sqrt(2)).locus(-135,P(0,0)),
        )
g.scale(1.5,.5)
render(g,file=...)
\end{python}
\begin{center}
  \includegraphics{fig_circle_eg2}
\end{center}
\end{example}

%--------------------------------------------------------------------------
\subsection{Dot()}
\label{sec:dot}
\begin{python}
class Dot(Circle):
    r=.1
    bg=Color(0)
    fg=None
\end{python}

A simple convenience function to draw a dot at the given location

%--------------------------------------------------------------------------
\subsection{Path()}
\label{sec:path}
%\begin{python}
%\end{python}

An abritrary path (line curve etc).

%--------------------------------------------------------------------------
\section{Text Objects}

%--------------------------------------------------------------------------
\subsection{Text()}
\label{sec:text}
\begin{python}
class Text(Area):
    A single line text object within an Area object
    
    text=''
    font="Times-Roman"
    size=12
    fg=Color(0)
    bg=None
    kerning=1
\end{python}
The \Verb|Text| object allows typesetting a simple string in a single
font. The usual postscript fonts are defined, these are (case
insensitive): \Verb|courier|, \Verb|courier_bold|,
\Verb|courier_boldoblique|, \Verb|courier_oblique|, \Verb|helvetica|,
\Verb|helvetica_bold|, \Verb|helvetica_boldoblique|,
\Verb|helvetica_oblique|, \Verb|symbol|, \Verb|times_bold|,
\Verb|times_bolditalic|, \Verb|times_italic|, \Verb|times_roman| and
\Verb|zapfdingbats|.

The text will use \emph{kerning} automatically, that is, the
letter spacing will be adjusted depending on the pair of letters so
that it looks nicer. The kerning can be turned of if necessary, see
example below.
\begin{example}
\begin{python}
t1=Text('SWEPT AWAY',kerning=0,size=20)
t2=Text('SWEPT AWAY',kerning=1,size=20,nw=t1.sw)
render(t1,t2,file=...)
\end{python}
\begin{center}
  \includegraphics{text_kerning}
\end{center}
\end{example}

Since \Verb|Text| is a subclass of \Verb|Area| then the usual compass points
(\Verb|n|, \Verb|ne|, etc) are defined and can be read or set.

%--------------------------------------------------------------------------
\subsection{TeX()}
\label{sec:tex}
\begin{python}
class TeX(Area):
    an TeX expression

    text=""
    fg=Color(0)
\end{python}

A \LaTeX{} object --- any \LaTeX expression, can be typeset and
positioned on the diagram.  The \LaTeX{} expression is passed to the
\Verb|latex| program followed by \Verb|dvips|, the resulting
postscript is parsed and forms the basis of the object. Obviously this
requires working \Verb|latex| and \Verb|dvips| distributions on your
system. We recommend setting up your \Verb|latex| distribution to
use postscript fonts, that way they can be scaled to any size.

One common pitfall is that the backslash ('\Verb|\|') is used in python
strings as an escape character and so gets interpreted by python before
the string gets passed to the \Verb|latex| program. The easiest work
around to this problem is to use python raw-strings --- just prepend an
``r'' to the string e.g. \Verb|r"$\alpha$"|.

The object inherits from the \Verb|Area| object, and can also be
scaled, rotated, etc. as will any of the other objects.
\begin{example}
\begin{python}
tex=TeX(r'$|\psi_t\rangle=e^{itH}|\psi_0\rangle$',w=P(.5,0))

g=Group()
for ii in range(0,360,60):
    g.append(tex.copy().rotate(ii,P(0,0)))

render(g,file=...)
\end{python}
\begin{center}
  \includegraphics{tex_example}
\end{center}
\end{example}
%--------------------------------------------------------------------------
\section{Groups}

\subsection{Group()}
\label{sec:group}
\begin{python}
class Group(Area):

    def __init__(self,*objects,**dict):

    def append(self,*objs):
        append object(s) to group

    def apply(self,**dict):
        apply attributes to all objects

    def recalc_size(self):
        recalculate internal container size based on objects within

    def __getitem__(self,i):
    def __setitem__(self,i,other):
    def __getslice__(self,i,j):
    def __setslice__(self,i,j,wert):
\end{python}

This is one of the key classes in \Verb|PyScript|. \Verb|Group()| acts
like a python list and groups together  \Verb|PyScript| objects. Objects
can be added to the group when you create it, e.g. \Verb|g=Group(det,b)|,
or appended afterwards, e.g. \Verb|g.append(head,tail)|. You can access the 
items in the group as you would a normal python list, e.g. \Verb|head=g[2]|.

When an item is added to the group, the groups bounding box is recalculated
and this allows the whole group to be positioned using \Verb|n|, \Verb|ne|
etc. If you modify an object after it's been added to the group you will
have to call the \Verb|.recalc_size()|| if you want the groups bounding box
to reflect it's contents, you may not want this under certain applications. 

\Verb|Groups()|'s can be nested without problem. All the items will be
rendered in the order they where added. 

The properties of the groups contents can be set \emph{en-masse} by
using the \Verb|.apply()| method. Objects that don't understand a
particular property will be skipped. e.g. \Verb|g.apply(linewidth=2)|.



%--------------------------------------------------------------------------
\section{Vectors and Matrices}

%--------------------------------------------------------------------------
\section{Other}

%--------------------------------------------------------------------------
\subsection{Color()}
\label{sec:color}
\begin{python}
class Color(PsObj)
    def __mul__(self,other)
\end{python}

This class represents a postscript color. There are four ways to specify
the color distinguished by the number and type of paprameters that
are passed when you create the object.

\begin{itemize}
\item \Verb|Color(C,M,Y,K)| - a postscript CMYKColor (Cyan, Magenta, Yellow, blacK) 
\item \Verb|Color(R,G,B)| - RGBColor (Red, Green, Blue)
\item \Verb|Color(G)| - Gray
\item \Verb|Color('Yellow')| etc
\end{itemize}

All the numbers above range from 0 to 1. Some of the named colors that
are defined are Red, Green, Blue, Cyan, Magenta, Yellow, Black, White.

Color objects can be multiplied by a numeric factor.  The effect is
mostly to darken colors if the factor is less than 1 and to lighten
colors if it's greater, but this depends on how the colors where
specified.  eg \Verb|Color(.2,.6,.6)*.5 = Color(.1,.3,.3)|

The colours in the named colour model are shown in figure
\ref{fig:colourchart}. As a historical note, the color names originated 
from unixes X11 color names, and were at one point considered as 
cadidate named colours for HTML documents, but in the end where
never adopted. They have however, aquired an unofficial permanence.
\begin{figure}[h]
\centerline{
  \includegraphics[height=0.8\textwidth]{fig_colorchart}
}
\caption{Named colors}
\label{fig:colourchart}
\end{figure}

A final note on the colors --- what you get on paper may not reflect
what you see on the screen. The actual color that turns up on the
paper is a complicated function of how it was produced, and depends on
the hardware. The fastest and most accurate way to match colors in a
printed document is to print out a color chart on the intended
hardware.


%--------------------------------------------------------------------------

\subsection{Paper()}
\label{sec:paper}
\begin{python}
class Paper(Area):
    PAPERSIZES={"a0", ...''letter'', ...}
\end{python}

This is a convenience class, just an \Verb|Area()| with predefined
size given by the usual paper sizes such as ``a4'', ``letter'' and
``legal'' etc. The origin is at the sw corner. It's useful if you want
an object that will help align things on a printed page. e.g.
\Verb|page=Paper("a4")|.

%--------------------------------------------------------------------------

\subsection{Epsf()}
\label{sec:epsf}
\begin{python}
class Epsf(Area):
\end{python}

Include an encapsulated postscript file (eps) in the figure. An eps
file is a single page postcript file describing a diagram. There are
many programs, such as graphing programs, that will generate eps files
as output.  It has to obey certain rules, such as having no page
brakes, and a bounding box.  \Verb|PyScript| will parse the file and
extract the bounding box and use that as the basis of the size and
placement of the figure. \Verb|Epsf()| takes a single argument --- the
path of the eps file. The resulting object can then be positioned using
\Verb|n|,\Verb|c| etc, and of cource can be scaled and rotated as desired.
%==========================================================================
\chapter{Development}

The aim of this section is to document some of the internals of
\Verb|pyscript| to enable developers to modify and extend it. 
It should also help in solving some of the trickier problems.

\begin{figure}[h]
  \begin{center}
    \begin{sideways}
      \includegraphics[height=.9\textwidth]{class_structure}
    \end{sideways}
  \end{center}
  \caption{Class structure of pyscript}
  \label{fig:classes}
\end{figure}

%--------------------------------------------------------------------------
%\section{Object Attributes}
%\label{sec:attributes}
%
%
%\subsection{Native vs Dynamic}
%\label{sec:native-vs-dynamic}
%
%Initialisation and setting of the attributes is somewhat complicated.  We
%want to be able to set attributes \`{a} la
%\Verb|Text('font'='Helvetica',sw=P(0,-1))|, but to give full functionality
%some attributes may need to be set on the fly, depending and affecting
%others.  This is done with two types of attributes, \emph{native} which are
%just dict entries and don't depend on anything else; and \emph{dynamic}
%which are actually functions which return or set the native attibutes.
%
%All classes that inherit from \Verb|PsDict| are dictionaries. 
%The following functions are special and implement the dynamic attributes:
%\begin{itemize}
%\item \Verb|_get_name(self)|: the returned value of this function is what is
%returned from the call \Verb|obj['name']|
%\item \Verb|_set_name(self,value)|: This function is executed by
%  \Verb|obj['name']='bob'|
%
%\end{itemize}
%So, to provide some dynamical attribute, it is only neccessary to define 
%the appropriately named functions. All classes in \Verb|pyscript|
%should use this mechanism to provide a consistent feel to the user.
%
%\subsection{Initialisation}
%\label{sec:initialisation}
%
%The class initialisation mechanism is motivated by the following
%requirements:
%
%\begin{itemize}
%\item Each class should set all its defaults for its native attributes
%\item Dynamic attributes can only be calculated/set after \emph{all} native
%  attributes have been set, including base classes!
%\item Supplied attributes override the defaults \ldots duh.
%\end{itemize}
%
%To initialise the attributes correctly, classes should first call
%\Verb|native(defaults,param)| to initialise all default native values, then
%call the initialisation of the parent class e.g.:
%\begin{python}
%def __init__(self,**dict):
%   
%   ...code to calculate native attributes...
%
%   self.natives({"width":0,"height":0},dict)
%   apply(PsObject.__init__,(self,),dict)
%
%   ...further initialisation...
%\end{python}
%
%
%
%%--------------------------------------------------------------------------
%\section{Co-ordinates and Affine Transformations}
%\label{sec:co-ordinates-affine}
%
%Abritrary affine transformations (e.g. rotations, scaling, shearing,
%reflection) can be applied to any object that is a subclass of 
%\Verb|PsObject|. The way it is implemented in postscript is that the 
%transformation is applied to the co-ordinate system \emph{before}
%the object is drawn. Hence the placement of the object on the page
%is actually a displacement of the \emph{internal} origin.
%
%There are two co-ordinate systems for each object. An \emph{internal}
%co-ordinate system in which the object is drawn. Usualy the origin (0,0) is
%somewhere convenient on the object. There is also an \emph{external}
%co-ordinate system which takes into account the placement, scaling etc. of
%the object. Co-ordinates can be converted from \emph{internal} to
%\emph{external} using the member function \Verb|itoe(point)| and vice-versa
%with \Verb|etoi(point)|.
%
%Points that are returned from an object (e.g. \Verb|area.nw|) should
%always be in the \emph{external} co-ordinates. In particular the origin,
%\Verb|obj.o| is always in \emph{external} co-ordinates [internally it
%just the point (0,0)]
%
%%--------------------------------------------------------------------------
%\section{Bounding Box}
%\label{sec:bounding-box}
%
%All objects subclassing \Verb|PsObject| must provide a \Verb|boundingbox()|
%function which returns the SW and NE points of a tight bounding box for the
%object (in \emph{external} co-ordinates). The bounding box will be used
%to calculate the bounding box for the entire drawing as way to allow
%the precise placement of objects.
%
%
%%--------------------------------------------------------------------------
%\section{Postscript Objects}
%\label{sec:postscript-objects}
%
%The basic class for implementing an object drawn directly in postscript
%is \Verb|PsObject|. 

\appendix

\include{pyscriptQuantInfo}

\include{pyscriptPlot}

\include{pyscriptElectronics}

\end{document}
